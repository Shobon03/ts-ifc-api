---
title: Backend Python
description: Servidor Flask para integração com Archicad
---

## Visão Geral

Backend Python (Flask) serve como ponte entre o backend Node.js e o plugin Archicad C++.

**Porta**: 5000
**Framework**: Flask 3.1.2
**Integração**: Archicad API Python wrapper

## Estrutura

```python
backend/python/
├── src/
│   ├── server.py           # Flask app
│   ├── archicad/
│   │   ├── __init__.py
│   │   ├── connection.py   # Archicad connection
│   │   └── converter.py    # Conversion logic
│   └── utils/
│       └── validation.py
├── requirements.txt
└── .env
```

## Instalação

**Requisitos**: Python 3.13

```bash
cd backend/python

# Crie virtual environment
python -m venv venv

# Ative (Windows)
venv\Scripts\activate

# Ou (Linux/Mac)
source venv/bin/activate

# Instale dependências
pip install -r requirements.txt
```

**requirements.txt**:
```txt
Flask==3.1.2
archicad==28.3000
python-dotenv==1.0.0
requests==2.32.0
flask-cors==5.0.0
```

## Servidor Flask

```python
# src/server.py
from flask import Flask, request, jsonify, send_file
from flask_cors import CORS
from dotenv import load_dotenv
import os

load_dotenv()

app = Flask(__name__)
CORS(app)

from archicad.converter import ArchicadConverter

converter = ArchicadConverter()

@app.route('/health', methods=['GET'])
def health():
    """Health check"""
    archicad_status = converter.check_connection()

    return jsonify({
        'status': 'ok',
        'archicad': 'connected' if archicad_status else 'disconnected'
    })

@app.route('/convert/archicad-to-ifc', methods=['POST'])
def convert_archicad_to_ifc():
    """
    Converte arquivo .pln do Archicad para IFC
    """
    if 'file' not in request.files:
        return jsonify({'error': 'No file provided'}), 400

    file = request.files['file']

    if not file.filename.endswith('.pln'):
        return jsonify({'error': 'Invalid file format'}), 400

    # Salva temporariamente
    input_path = f'/tmp/{file.filename}'
    file.save(input_path)

    # Converte
    try:
        output_path = converter.convert_to_ifc(input_path)
        return send_file(output_path, as_attachment=True)

    except Exception as e:
        return jsonify({'error': str(e)}), 500

    finally:
        # Limpa arquivos temporários
        if os.path.exists(input_path):
            os.remove(input_path)

if __name__ == '__main__':
    port = int(os.getenv('FLASK_PORT', 5000))
    app.run(host='0.0.0.0', port=port, debug=True)
```

## Integração Archicad

```python
# src/archicad/connection.py
from archicad import ACConnection, releases

class ArchicadConnectionManager:
    def __init__(self):
        self.conn = None

    def connect(self):
        """Conecta ao Archicad em execução"""
        try:
            self.conn = ACConnection.connect()
            return True
        except Exception as e:
            print(f"Failed to connect: {e}")
            return False

    def is_connected(self):
        """Verifica se está conectado"""
        return self.conn is not None

    def get_project_info(self):
        """Obtém informações do projeto aberto"""
        if not self.is_connected():
            return None

        try:
            info = self.conn.commands.GetProjectInfo()
            return info
        except:
            return None
```

```python
# src/archicad/converter.py
from archicad import ACConnection
import os

class ArchicadConverter:
    def __init__(self):
        self.conn = None

    def check_connection(self):
        """Verifica conexão com Archicad"""
        try:
            self.conn = ACConnection.connect()
            return True
        except:
            return False

    def convert_to_ifc(self, pln_path: str) -> str:
        """
        Converte .pln para .ifc

        Args:
            pln_path: Caminho do arquivo .pln

        Returns:
            Caminho do arquivo .ifc gerado
        """
        if not self.conn:
            self.conn = ACConnection.connect()

        # Abre projeto
        self.conn.commands.Open(pln_path)

        # Define caminho de saída
        output_path = pln_path.replace('.pln', '.ifc')

        # Configurações de exportação IFC
        ifc_settings = {
            'version': '2x3',  # ou '4'
            'exportFilter': 'Visible Elements',
            'coordinates': 'Project Origin'
        }

        # Exporta IFC (via plugin C++)
        # Nota: Requer plugin instalado no Archicad
        self.conn.commands.SaveAs(output_path, 'IFC', ifc_settings)

        # Fecha projeto
        self.conn.commands.Close()

        return output_path

    def import_ifc(self, ifc_path: str, target_pln: str = None):
        """
        Importa IFC para Archicad (futuro)
        """
        if not self.conn:
            self.conn = ACConnection.connect()

        if target_pln:
            self.conn.commands.Open(target_pln)
        else:
            self.conn.commands.NewProject()

        # Importa IFC
        self.conn.commands.Open(ifc_path, mode='Merge')

        if target_pln:
            self.conn.commands.Save()
        else:
            output_path = ifc_path.replace('.ifc', '_imported.pln')
            self.conn.commands.SaveAs(output_path)

        return output_path if not target_pln else target_pln
```

## Executando

### Desenvolvimento

```bash
# Ative venv
source venv/bin/activate  # ou venv\Scripts\activate no Windows

# Execute
python src/server.py

# Servidor rodando em http://localhost:5000
```

### Produção (gunicorn)

```bash
pip install gunicorn

gunicorn -w 4 -b 0.0.0.0:5000 src.server:app
```

## Testando

```bash
# Health check
curl http://localhost:5000/health

# Converter arquivo
curl -X POST http://localhost:5000/convert/archicad-to-ifc \
  -F "file=@test-model.pln" \
  --output model.ifc
```

## Limitações Atuais

- Requer Archicad rodando localmente
- Plugin C++ deve estar instalado
- Sem suporte a WebSocket (apenas HTTP)
- Conversão síncrona (bloqueante)

## Melhorias Futuras

- Adicionar WebSocket (como Revit plugin)
- Suporte a filas de conversão (Celery/RQ)
- Cache de resultados
- Métricas e logging estruturado
